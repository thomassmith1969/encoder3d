/**
 * GCode Generator
 * Converts toolpaths to GCode commands
 * Optimized for encoder-driven PID motor system
 */

class GCodeGenerator {
    constructor() {
        this.settings = {};
        this.currentPosition = { x: 0, y: 0, z: 0, e: 0 };
        this.gcode = [];
    }

    /**
     * Generate complete GCode from sliced layers
     * @param {Array} layers - Sliced layers with paths
     * @param {Object} settings - Print settings
     * @returns {String} Complete GCode
     */
    generate(layers, settings) {
        this.settings = settings;
        this.gcode = [];
        this.currentPosition = { x: 0, y: 0, z: 0, e: 0 };
        
        // Start GCode
        this.addStartGCode();
        
        // Process each layer
        layers.forEach((layer, index) => {
            this.addLayerGCode(layer, index);
        });
        
        // End GCode
        this.addEndGCode();
        
        return this.gcode.join('\n');
    }

    /**
     * Add start GCode sequence
     */
    addStartGCode() {
        const s = this.settings;
        
        this.addComment('Generated by Encoder3D Slicer');
        this.addComment(`Print Settings:`);
        this.addComment(`  Layer Height: ${s.layerHeight}mm`);
        this.addComment(`  Infill: ${s.infillDensity}%`);
        this.addComment(`  Wall Count: ${s.wallCount}`);
        this.addComment(`  Nozzle Temp: ${s.nozzleTemp}°C`);
        this.addComment(`  Bed Temp: ${s.bedTemp}°C`);
        this.addComment(`  Print Speed: ${s.printSpeed}mm/s`);
        this.addComment('');
        
        this.addComment('Start GCode');
        this.add(`M104 S${s.nozzleTemp} T0`, 'Set nozzle temperature');
        this.add(`M140 S${s.bedTemp}`, 'Set bed temperature');
        this.add('G21', 'Metric units');
        this.add('G90', 'Absolute positioning');
        this.add('M82', 'Absolute extrusion');
        this.add('G28', 'Home all axes');
        this.add(`M109 S${s.nozzleTemp} T0`, 'Wait for nozzle temp');
        this.add(`M190 S${s.bedTemp}`, 'Wait for bed temp');
        this.add('G92 E0', 'Reset extruder');
        
        // Prime line
        this.addComment('Prime nozzle');
        this.add('G1 Z2.0 F3000', 'Lift Z');
        this.add('G1 X10 Y10 F5000', 'Move to start');
        this.add('G1 Z0.3 F3000', 'Lower Z');
        this.add('G1 X60 E9 F1000', 'Prime line');
        this.add('G1 X100 E12.5 F1000', 'Prime line');
        this.add('G92 E0', 'Reset extruder');
        this.add('G1 Z2.0 F3000', 'Lift Z');
        this.addComment('');
    }

    /**
     * Add GCode for a single layer
     */
    addLayerGCode(layer, layerIndex) {
        const s = this.settings;
        
        this.addComment(`LAYER: ${layerIndex}`);
        this.addComment(`Z: ${layer.z.toFixed(3)}mm`);
        
        // Move to layer height
        this.add(`G1 Z${layer.z.toFixed(3)} F${s.travelSpeed || 5000}`, 'Move to layer height');
        
        // Print perimeters (outer walls first)
        if (layer.perimeters && layer.perimeters.length > 0) {
            this.addComment('Perimeters');
            layer.perimeters.forEach(perimeter => {
                // Allow per-path speed override (from per-object settings)
                const fallbackSpeed = (perimeter.type === 'outer-wall')
                    ? (s.perimeterSpeed || s.printSpeed)
                    : (s.innerPerimeterSpeed || s.perimeterSpeed || s.printSpeed);
                const speed = (perimeter.speed !== undefined && perimeter.speed !== null)
                    ? perimeter.speed
                    : fallbackSpeed;
                this.addPath(perimeter, speed);
            });
        }
        
        // Print infill
        if (layer.infill && layer.infill.length > 0) {
            this.addComment('Infill');
            layer.infill.forEach(infillPath => {
                const fallbackSpeed = s.infillSpeed || s.printSpeed * 1.5;
                const speed = (infillPath.speed !== undefined && infillPath.speed !== null)
                    ? infillPath.speed
                    : fallbackSpeed;
                this.addPath(infillPath, speed);
            });
        }
        
        this.addComment('');
    }

    /**
     * Add GCode for a single path (perimeter or infill line)
     */
    addPath(path, speed) {
        if (!path.points || path.points.length < 2) return;
        
        const points = path.points;
        const lineWidth = path.width || this.settings.lineWidth || 0.4;
        const layerHeight = this.settings.layerHeight || 0.2;
        const filamentDiameter = this.settings.filamentDiameter || 1.75;
        
        // Move to start (travel move)
        const startPoint = points[0];
        if (!this.isAtPosition(startPoint.x, startPoint.y)) {
            // Retract before travel
            if (this.settings.retraction && this.settings.retraction > 0) {
                this.add(`G1 E${(this.currentPosition.e - this.settings.retraction).toFixed(5)} F${this.settings.retractionSpeed || 1800}`, 'Retract');
            }
            
            this.add(`G0 X${startPoint.x.toFixed(3)} Y${startPoint.y.toFixed(3)} F${this.settings.travelSpeed || 5000}`, 'Travel');
            
            // Un-retract
            if (this.settings.retraction && this.settings.retraction > 0) {
                this.currentPosition.e += this.settings.retraction;
                this.add(`G1 E${this.currentPosition.e.toFixed(5)} F${this.settings.retractionSpeed || 1800}`, 'Un-retract');
            }
        }
        
        this.currentPosition.x = startPoint.x;
        this.currentPosition.y = startPoint.y;
        
        // Extrude along path
        for (let i = 1; i < points.length; i++) {
            const point = points[i];
            const distance = this.distance3D(this.currentPosition, { x: point.x, y: point.y, z: this.currentPosition.z });
            
            // Calculate extrusion amount
            const extrusionVolume = distance * layerHeight * lineWidth;
            const filamentArea = Math.PI * Math.pow(filamentDiameter / 2, 2);
            const extrusionLength = extrusionVolume / filamentArea;
            
            this.currentPosition.e += extrusionLength;
            this.currentPosition.x = point.x;
            this.currentPosition.y = point.y;
            
            this.add(`G1 X${point.x.toFixed(3)} Y${point.y.toFixed(3)} E${this.currentPosition.e.toFixed(5)} F${Math.round(speed * 60)}`);
        }
    }

    /**
     * Add end GCode sequence
     */
    addEndGCode() {
        this.addComment('End GCode');
        this.add('G91', 'Relative positioning');
        this.add('G1 Z10 F3000', 'Lift nozzle');
        this.add('G90', 'Absolute positioning');
        this.add('G1 X0 Y200 F5000', 'Present print');
        this.add('M104 S0', 'Turn off nozzle');
        this.add('M140 S0', 'Turn off bed');
        this.add('M107', 'Turn off fan');
        this.add('M84', 'Disable motors');
        this.addComment('Print complete!');
    }

    /**
     * Add a GCode line with optional comment
     */
    add(command, comment) {
        if (comment) {
            this.gcode.push(`${command} ; ${comment}`);
        } else {
            this.gcode.push(command);
        }
    }

    /**
     * Add a comment line
     */
    addComment(text) {
        this.gcode.push(`; ${text}`);
    }

    /**
     * Check if current position matches target
     */
    isAtPosition(x, y, tolerance = 0.01) {
        return Math.abs(this.currentPosition.x - x) < tolerance &&
               Math.abs(this.currentPosition.y - y) < tolerance;
    }

    /**
     * Calculate 3D distance between points
     */
    distance3D(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const dz = (p2.z || 0) - (p1.z || 0);
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    /**
     * Estimate print time from GCode
     */
    estimatePrintTime(gcode) {
        const lines = gcode.split('\n');
        let totalTime = 0;
        let pos = { x: 0, y: 0, z: 0, e: 0 };
        
        lines.forEach(line => {
            const match = line.match(/G[01]\s+.*F(\d+)/);
            if (match) {
                const feedrate = parseInt(match[1]);
                
                // Extract coordinates
                const xMatch = line.match(/X([\d.-]+)/);
                const yMatch = line.match(/Y([\d.-]+)/);
                const zMatch = line.match(/Z([\d.-]+)/);
                
                if (xMatch || yMatch || zMatch) {
                    const newPos = {
                        x: xMatch ? parseFloat(xMatch[1]) : pos.x,
                        y: yMatch ? parseFloat(yMatch[1]) : pos.y,
                        z: zMatch ? parseFloat(zMatch[1]) : pos.z
                    };
                    
                    const distance = this.distance3D(pos, newPos);
                    totalTime += (distance / (feedrate / 60));
                    
                    pos = newPos;
                }
            }
        });
        
        const hours = Math.floor(totalTime / 3600);
        const minutes = Math.floor((totalTime % 3600) / 60);
        const seconds = Math.floor(totalTime % 60);
        
        return `${hours}h ${minutes}m ${seconds}s`;
    }
}

// Export for Node.js testing
if (typeof module !== 'undefined' && module.exports) {
    module.exports = GCodeGenerator;
}
