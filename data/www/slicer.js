/*
 * Encoder3D CNC Controller - Basic G-Code Slicer
 * 
 * Copyright (c) 2025 Encoder3D Project Contributors
 * Licensed under the MIT License. See LICENSE file for details.
 */

let generatedGCode = '';
let slicedFilename = '';

// Simple slicer - converts STL to basic G-code
function sliceModel() {
    if (!currentModel) {
        alert('Please load an STL file first');
        return;
    }

    const layerHeight = parseFloat(document.getElementById('layer-height').value);
    const firstLayerHeight = parseFloat(document.getElementById('first-layer-height').value);
    const infill = parseInt(document.getElementById('infill').value);
    const printSpeed = parseInt(document.getElementById('print-speed').value);
    const nozzleTemp = parseInt(document.getElementById('slice-nozzle-temp').value);
    const bedTemp = parseInt(document.getElementById('slice-bed-temp').value);
    const wallLines = parseInt(document.getElementById('wall-lines').value);
    const topLayers = parseInt(document.getElementById('top-layers').value);
    const bottomLayers = parseInt(document.getElementById('bottom-layers').value);

    // Show progress
    document.getElementById('slice-progress').style.display = 'block';
    document.getElementById('slice-progress-text').textContent = 'Analyzing model...';

    // Run slicing in a timeout to allow UI update
    setTimeout(() => {
        try {
            const gcode = generateGCode({
                geometry: currentModel.geometry,
                layerHeight,
                firstLayerHeight,
                infill,
                printSpeed,
                nozzleTemp,
                bedTemp,
                wallLines,
                topLayers,
                bottomLayers
            });

            generatedGCode = gcode;
            slicedFilename = document.getElementById('model-name').textContent.replace('.stl', '.gcode');
            
            // Display G-code
            document.getElementById('gcode-preview').value = gcode;
            
            // Update stats
            updateGCodeStats(gcode);
            
            document.getElementById('slice-progress').style.display = 'none';
            console.log('Slicing complete');
            
        } catch (error) {
            console.error('Slicing error:', error);
            alert('Slicing failed: ' + error.message);
            document.getElementById('slice-progress').style.display = 'none';
        }
    }, 100);
}

function generateGCode(settings) {
    const { geometry, layerHeight, firstLayerHeight, infill, printSpeed, nozzleTemp, bedTemp, wallLines } = settings;
    
    geometry.computeBoundingBox();
    const bbox = geometry.boundingBox;
    const size = new THREE.Vector3();
    bbox.getSize(size);
    
    let gcode = '';
    
    // Header
    gcode += '; Generated by Encoder3D Slicer\n';
    gcode += `; Model size: ${size.x.toFixed(2)}x${size.y.toFixed(2)}x${size.z.toFixed(2)}mm\n`;
    gcode += `; Layer height: ${layerHeight}mm\n`;
    gcode += `; Infill: ${infill}%\n\n`;
    
    // Start G-code
    gcode += '; Start G-code\n';
    gcode += 'G21 ; Set units to millimeters\n';
    gcode += 'G90 ; Absolute positioning\n';
    gcode += 'M82 ; Absolute extrusion\n';
    gcode += `M104 S${nozzleTemp} ; Set hotend temp\n`;
    gcode += `M140 S${bedTemp} ; Set bed temp\n`;
    gcode += 'G28 ; Home all axes\n';
    gcode += `M109 S${nozzleTemp} ; Wait for hotend\n`;
    gcode += `M190 S${bedTemp} ; Wait for bed\n`;
    gcode += 'G92 E0 ; Reset extruder\n\n';
    
    // Simple rectangular perimeter slicing
    const layers = Math.ceil(size.z / layerHeight);
    const minX = bbox.min.x;
    const minY = bbox.min.y;
    const maxX = bbox.max.x;
    const maxY = bbox.max.y;
    
    let e = 0; // Extrusion amount
    const extrusionPerMM = 0.02; // Simple extrusion rate
    
    gcode += `; Printing ${layers} layers\n\n`;
    
    for (let layer = 0; layer < Math.min(layers, 100); layer++) { // Limit to 100 layers for demo
        const z = bbox.min.z + (layer === 0 ? firstLayerHeight : layerHeight * (layer + 1));
        const speed = layer === 0 ? printSpeed / 2 : printSpeed;
        
        gcode += `; Layer ${layer + 1}\n`;
        gcode += `G0 Z${z.toFixed(2)} F${speed * 60}\n`;
        
        // Outer perimeter (simplified - just rectangle)
        for (let wall = 0; wall < wallLines; wall++) {
            const offset = wall * 0.4; // Nozzle width
            const x0 = minX + offset;
            const y0 = minY + offset;
            const x1 = maxX - offset;
            const y1 = maxY - offset;
            
            // Move to start
            if (layer === 0 && wall === 0) {
                gcode += `G0 X${x0.toFixed(2)} Y${y0.toFixed(2)} F${speed * 60}\n`;
            }
            
            // Perimeter
            const perimeterPoints = [
                [x0, y0], [x1, y0], [x1, y1], [x0, y1], [x0, y0]
            ];
            
            for (let i = 1; i < perimeterPoints.length; i++) {
                const [x, y] = perimeterPoints[i];
                const [prevX, prevY] = perimeterPoints[i - 1];
                const dist = Math.sqrt(Math.pow(x - prevX, 2) + Math.pow(y - prevY, 2));
                e += dist * extrusionPerMM;
                gcode += `G1 X${x.toFixed(2)} Y${y.toFixed(2)} E${e.toFixed(4)} F${speed * 60}\n`;
            }
        }
        
        // Simple infill (diagonal lines)
        if (infill > 0 && layer > settings.bottomLayers && layer < layers - settings.topLayers) {
            const infillSpacing = 2.0 / (infill / 100); // Spacing based on infill %
            const diagonal = (layer % 2 === 0);
            
            if (diagonal) {
                for (let x = minX; x < maxX; x += infillSpacing) {
                    e += size.y * extrusionPerMM * 0.5;
                    gcode += `G1 X${x.toFixed(2)} Y${minY.toFixed(2)} E${e.toFixed(4)}\n`;
                    e += size.y * extrusionPerMM * 0.5;
                    gcode += `G1 X${(x + infillSpacing).toFixed(2)} Y${maxY.toFixed(2)} E${e.toFixed(4)}\n`;
                }
            }
        }
        
        gcode += '\n';
    }
    
    if (layers > 100) {
        gcode += `; Note: Only first 100 of ${layers} layers shown (demo limitation)\n\n`;
    }
    
    // End G-code
    gcode += '; End G-code\n';
    gcode += 'G92 E0 ; Reset extruder\n';
    gcode += 'G1 E-2 F2400 ; Retract\n';
    gcode += 'G0 Z10 ; Raise Z\n';
    gcode += 'G28 X Y ; Home X Y\n';
    gcode += 'M104 S0 ; Turn off hotend\n';
    gcode += 'M140 S0 ; Turn off bed\n';
    gcode += 'M84 ; Disable motors\n';
    
    return gcode;
}

function updateGCodeStats(gcode) {
    const lines = gcode.split('\n').filter(l => l.trim().length > 0 && !l.trim().startsWith(';'));
    document.getElementById('gcode-lines').textContent = lines.length;
    
    // Estimate print time (very rough)
    const estimatedMinutes = Math.ceil(lines.length * 0.05); // ~3 seconds per line average
    const hours = Math.floor(estimatedMinutes / 60);
    const minutes = estimatedMinutes % 60;
    document.getElementById('gcode-time').textContent = 
        hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
    
    // Estimate filament (rough calculation from extrusion)
    const extrusionMatches = gcode.match(/E(\d+\.\d+)/g);
    if (extrusionMatches && extrusionMatches.length > 0) {
        const maxE = Math.max(...extrusionMatches.map(e => parseFloat(e.substring(1))));
        const filamentMM = maxE;
        const filamentM = (filamentMM / 1000).toFixed(2);
        document.getElementById('gcode-filament').textContent = `${filamentM}m`;
    }
    
    // File size
    const sizeKB = (new Blob([gcode]).size / 1024).toFixed(1);
    document.getElementById('gcode-size').textContent = `${sizeKB} KB`;
}

function downloadGCode() {
    if (!generatedGCode) {
        alert('No G-code to download. Slice a model first.');
        return;
    }

    const blob = new Blob([generatedGCode], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = slicedFilename || 'sliced.gcode';
    a.click();
    URL.revokeObjectURL(url);
}

async function uploadSlicedGCode() {
    if (!generatedGCode) {
        alert('No G-code to upload. Slice a model first.');
        return;
    }

    const sizeKB = new Blob([generatedGCode]).size / 1024;
    if (sizeKB > 100) {
        alert(`File too large for LittleFS (${sizeKB.toFixed(1)}KB > 100KB). Use SD card instead.`);
        return;
    }

    const filename = prompt('Enter filename:', slicedFilename || 'sliced.gcode');
    if (!filename) return;

    try {
        const formData = new FormData();
        const blob = new Blob([generatedGCode], { type: 'text/plain' });
        formData.append('file', blob, filename);

        const response = await fetch('/api/littlefs/upload', {
            method: 'POST',
            body: formData
        });

        if (response.ok) {
            alert('G-code uploaded to LittleFS successfully!');
            addToConsole(`Uploaded ${filename} to LittleFS`);
        } else {
            throw new Error('Upload failed');
        }
    } catch (error) {
        console.error('Upload error:', error);
        alert('Failed to upload G-code: ' + error.message);
    }
}

async function uploadSlicedToSD() {
    if (!generatedGCode) {
        alert('No G-code to upload. Slice a model first.');
        return;
    }

    const filename = prompt('Enter filename:', slicedFilename || 'sliced.gcode');
    if (!filename) return;

    try {
        const formData = new FormData();
        const blob = new Blob([generatedGCode], { type: 'text/plain' });
        formData.append('file', blob, filename);

        const response = await fetch('/api/upload', {
            method: 'POST',
            body: formData
        });

        if (response.ok) {
            alert('G-code uploaded to SD card successfully!');
            addToConsole(`Uploaded ${filename} to SD card`);
        } else {
            throw new Error('Upload failed');
        }
    } catch (error) {
        console.error('Upload error:', error);
        alert('Failed to upload G-code: ' + error.message);
    }
}
